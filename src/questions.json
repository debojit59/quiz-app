{
  "questions": [
    {
      "question": "Which key choice most commonly causes state bugs when a list can be reordered?",
      "options": [
        "Database id",
        "Array index",
        "Composite of stable fields",
        "Slug"
      ],
      "correctOption": 1,
      "points": 25
    },
    {
      "question": "useEffect(() => {...}, []) runs:",
      "options": [
        "Before paint (blocking)",
        "Once after initial render on the client",
        "During SSR as well",
        "On every render"
      ],
      "correctOption": 1,
      "points": 20
    },
    {
      "question": "What actually shows a <Suspense> fallback?",
      "options": [
        "Child returns null",
        "Child throws a Promise while rendering",
        "setState(null) in child",
        "Parent sets loading = true"
      ],
      "correctOption": 1,
      "points": 30
    },
    {
      "question": "You pass an inline arrow function prop to a React.memo child. How do you avoid unnecessary re-renders?",
      "options": [
        "Only React.memo on child",
        "Wrap parent in React.memo",
        "useCallback in parent AND React.memo on child",
        "useMemo in child"
      ],
      "correctOption": 2,
      "points": 25
    },
    {
      "question": "When is startTransition useful?",
      "options": [
        "To make updates synchronous",
        "To mark non-urgent updates so typing stays responsive",
        "To delay effects until after paint",
        "To batch across roots"
      ],
      "correctOption": 1,
      "points": 25
    },
    {
      "question": "Which is TRUE about refs?",
      "options": [
        "Changing ref.current triggers re-render",
        "Refs are serialized on SSR",
        "useRef must be in effect deps",
        "Mutating ref.current does not re-render"
      ],
      "correctOption": 3,
      "points": 20
    },
    {
      "question": "Which values belong in a useEffect dependency array?",
      "options": [
        "Usually none",
        "All state and props referenced by the effect",
        "Only state variables",
        "Only values that rarely change"
      ],
      "correctOption": 1,
      "points": 30
    },
    {
      "question": "Which situation is most likely to cause hydration mismatch in Next.js?",
      "options": [
        "Using deterministic classNames",
        "Rendering Date.now() directly in output without stabilizing",
        "Using useEffect to set state",
        "Using static metadata"
      ],
      "correctOption": 1,
      "points": 30
    },
    {
      "question": "In Next.js App Router, default fetch() behavior in a Server Component is:",
      "options": [
        "No cache; always refetch",
        "Cached & request-deduped by default",
        "Throws unless wrapped in cache()",
        "Uses no-store by default"
      ],
      "correctOption": 1,
      "points": 35
    },
    {
      "question": "A component uses useContext(MyCtx). It re-renders when:",
      "options": [
        "The provider's value reference changes",
        "A sibling updates",
        "The value is deeply unequal only",
        "Never; it reads once"
      ],
      "correctOption": 0,
      "points": 25
    },
    {
      "question": "Which statement about useMemo is TRUE?",
      "options": [
        "Prevents component re-renders",
        "Caches forever until unmount",
        "Memoizes a value between renders but React may discard it; not a cache guarantee",
        "Always makes computation faster"
      ],
      "correctOption": 2,
      "points": 25
    },
    {
      "question": "Which pattern most often causes stale closures?",
      "options": [
        "Reading state inside setInterval without functional updates/refs",
        "Using refs for mutable values",
        "Including full deps in effects",
        "Using useMemo for expensive calc"
      ],
      "correctOption": 0,
      "points": 30
    }
  ]
}
